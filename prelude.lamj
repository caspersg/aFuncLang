xor=
  a: b: or (and a (not b)) (and (not a) b)

#lisp list definition
#(define (cons x y)
#  (lambda (m) (m x y)))
#(define (car z)
#  (z (lambda (p q) p)))
#(define (cdr z)
#  (z (lambda (p q) q)))

cons =
  x: y: m: m x y
head =
  z: z (p: q: p)
tail =
  z: z (p: q: q)

# haskell fold
#foldl f z []     = z
#foldl f z (x:xs) = foldl f (f z x) xs

#foldr f z []     = z
#foldr f z (x:xs) = f x (foldr f z xs)

# haskell map
#map f = foldr ((:) . f) []

# haskell compose
#f (g x) = (f . g) x

compose=
  fa: fb: x: fa (fb x)
    
map=
  f: foldr (compose cons f) _

foldl=
  f:
    z:
      _: z
      l: foldl f (f z (head l)) (tail l)

foldr=
  f:
    z:
      _: z
      l: f (head l) (foldr f z (tail l))

# haskell filter
#filter :: (a -> Bool) -> [a] -> [a]
# filter _ []                 = []
# filter p (x:xs) | p x       = x : filter p xs
#                 | otherwise = filter p xs
filter=
  p:
    _:_
    {l: p (head l)}: cons (head l) (filter p (tail l))
    l: filter p (tail l)

# lisp append
# (define append
#   (lambda (a b)
#      (fold-right cons b a)))
append=
  a: b: foldr (cons a b) _

# alternative filter' p xs = foldr (\x xs -> if p x then x : xs else xs) [] xs
filter=
  p: 
    test= 
      {x: p x}: xs: cons x xs
      x: xs: xs
    foldr test _

last=
  _:_
  {l: equal (tail l) _}: head l
  l: last (tail l)

# any in terms of filter
any=
  p:
    _: false
    {l: p (head l)}: true
    l: filter p (tail l)

# any in terms of foldr
any=
  p:
    test= 
      {x: p x}: xs: or x xs
      x: xs: false
    foldr test true

all=
  p:
    test= 
      {x: p x}: xs: and x xs
      x: xs: false
    foldr test true

