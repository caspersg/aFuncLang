xor=
  a: b: or (and a (not b)) (and (not a) b)

implies=
  a: b: or (not a) b

equivilant=
  a: b: not (xor a b)

# an alternative implementation for basic algebra
or=
  _: b: b
  a: b: a

not=
  _: true
  x: false

and=
  _: b: false
  a:
    _: false
    b: true

#lisp list definition
#(define (cons x y)
#  (lambda (m) (m x y)))
#(define (car z)
#  (z (lambda (p q) p)))
#(define (cdr z)
#  (z (lambda (p q) q)))

cons =
  x: y: m: m x y
head =
  z: z (p: q: p)
tail =
  z: z (p: q: q)

# haskell fold
#foldl f z []     = z
#foldl f z (x:xs) = foldl f (f z x) xs

#foldr f z []     = z
#foldr f z (x:xs) = f x (foldr f z xs)

# haskell compose
#f (g x) = (f . g) x

compose=
  fa: fb: x: fa (fb x)
    
# haskell map
#map f = foldr ((:) . f) []

map=
  f: foldr (compose cons f) _

foldl=
  f:
    z:
      _: z
      l: foldl f (f z (head l)) (tail l)

foldr=
  f:
    z:
      _: z
      l: f (head l) (foldr f z (tail l))

# haskell filter
#filter :: (a -> Bool) -> [a] -> [a]
# filter _ []                 = []
# filter p (x:xs) | p x       = x : filter p xs
#                 | otherwise = filter p xs
filter=
  p:
    _:_
    {l: p (head l)}: cons (head l) (filter p (tail l))
    l: filter p (tail l)

# lisp append
# (define append
#   (lambda (a b)
#      (fold-right cons b a)))
# haskell append
#append :: [a] -> [a] -> [a]
#append xs ys = foldr (:) ys xs
append=
  xs: ys: foldr cons ys xs

# haskell concat
#concat :: [[a]] -> [a]
#concat xs = build (\c n -> foldr (\x y -> foldr c y x) n xs)
# scala flatmap (same as haskell concatMap)
#def flatMap[A, B](list: List[A])(f: A => List[B]): List[B] = list match {
#  case (x::xs) => f(x) ++ flatMap(xs)(f)
#  case _ => Nil
#}
concat=
  _: _
  l: append (head l) (concat (tail l))

# alternative filter' p xs = foldr (\x xs -> if p x then x : xs else xs) [] xs
filter=
  p: 
    test= 
      {x: p x}: xs: cons x xs
      x: xs: xs
    foldr test _

last=
  _:_
  {l: equal (tail l) _}: head l
  l: last (tail l)

# any in terms of filter
any=
  p:
    _: false
    {l: p (head l)}: true
    l: filter p (tail l)

# any in terms of foldr
any=
  p:
    test= 
      {x: p x}: xs: or x xs
      x: xs: false
    foldr test true

all=
  p:
    test= 
      {x: p x}: xs: and x xs
      x: xs: false
    foldr test true


listM= :_

# monads
# List monad
#  // unit :: a -> [a]
listM_unit= x: cons x _

# // bind :: (a -> [a]) -> ([a] -> [a])
listM_bind=
  f: l: concat (map f l)

#maybe
nothing=
  "isJust": false
  "fromJust": _
just=
  a: 
    "isJust": true
    "fromJust": a

maybeM_unit= x: just x

maybeM_bind=
  f:
    {x: x "isJust"}: just (f (x "fromJust"))
    n: nothing

# curry some useful javascript functions
assertEqual = curry assert.equal
# maths
add = curry jsPlus
subtract = curry jsMinus
multiply = curry jsMultiply
divide = curry jsDivide
modulus = curry jsModulus
min = curry Math.min
max = curry Math.max
pow = curry Math.pow
# comparison
lessThan = curry jsLessThan
lessThanEqual = curry jsLessThanEqual
equal = curry jsEqual
greaterThan = not lessThanEqual
greaterThanEqual = not lessThan

